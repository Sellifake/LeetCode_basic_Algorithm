# 统计最大元素出现至少 K 次的子数组

## 题目描述
给你一个整数数组 `nums` 和一个正整数 `k` 。
请你统计有多少满足 `nums` 中的最大元素至少出现 `k` 次的子数组，并返回满足这一条件的子数组的数目。
子数组是数组中的一个连续元素序列。

示例 1：
输入：`nums = [1,3,2,3,3], k = 2`
输出：`6`
解释：包含元素 `3` 至少 `2` 次的子数组为：`[1,3,2,3]、[1,3,2,3,3]、[3,2,3]、[3,2,3,3]、[2,3,3] 和 [3,3]`。

示例 2：
输入：`nums = [1,4,2,1], k = 3`
输出：`0`
解释：没有子数组包含元素 `4` 至少 `3` 次。

## 解题思路
- 首先找到最大元素`max_ele`，再找到最大元素后需要有一个变量`count`记录最大元素出现的次数，当`count`大于等于`k`时，开始计算子数组个数。
```python
    while count == k:
        if nums[left] == max_ele:
            count -= 1
        left += 1
    ans += left
```
- 这里最一开始编程错误，将`ans`放在了`while`里面更新， 即`ans += 1`，这种更新方式会漏掉答案。
- ox3f题解原文`如果此时 count=k，则不断右移左指针 left，直到窗口内的 max_ele 的出现次数小于 k 为止。对于右端点为 right 且左端点小于 left 的子数组，max_ele 的出现次数都至少为 k，把答案增加 left`。
- 这里的意思是说如果在当前`left`和`right`状态下满足了条件，那么将`left`向左移包含更多的元素的子数组同样满足条件，这些子数组也是将`ans`放在了`while`里面更新漏掉的答案。那么为什么不加上`right`右侧的元素呢，因为`right`指针还在不断右移，在移动的过程中会重复计算。

```python
    for x in nums:
```
- 为什么`for`循环只需要`nums`中的数值不需要写`right`呢，因为这次更新答案不需要`right`了。