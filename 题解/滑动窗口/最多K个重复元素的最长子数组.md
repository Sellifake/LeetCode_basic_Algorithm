# 最多 K 个重复元素的最长子数组

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` 。
一个元素 `x`在数组中的`频率`指的是它在数组中的出现次数。
如果一个数组中所有元素的频率都 小于等于 `k` ，那么我们称这个数组是**好**数组。
请你返回`nums`中最长好子数组的长度。
子数组指的是一个数组中一段连续非空的元素序列。

示例 1：
输入：`nums = [1,2,3,1,2,3,1,2]`, `k = 2`
输出：`6`
解释：最长好子数组是 `[1,2,3,1,2,3]` ，值 1 ，2 和 3 在子数组中的频率都没有超过 `k = 2` 。`[2,3,1,2,3,1]` 和 `[3,1,2,3,1,2]` 也是好子数组。
最长好子数组的长度为`6` 。

示例 2：
输入：`nums = [1,2,1,2,1,2,1,2]`, `k = 1`
输出：`2`
解释：最长好子数组是 `[1,2]` ，值`1`和`2`在子数组中的频率都没有超过`k = 1`。`[2,1]`也是好子数组。
最长好子数组的长度为`2`。

示例 3：
输入：`nums = [5,5,5,5,5,5,5]`, `k = 4`
输出：`4`
解释：最长好子数组是 `[5,5,5,5]` ，值 `5` 在子数组中的频率没有超过`k = 4`。
最长好子数组的长度为`4`。

## 解题思路
- 依然使用滑动窗口，只不过需要记录窗口中每个元素出现的次数。`cnt = Counter()` 是在 `Python` 中使用 `collections.Counter` 类的一个实例。`Counter` 是一个专门用于计数的字典，它的作用是帮助你统计元素的出现次数。当遍历数组 `nums` 时，每遇到一个数字 `x`，就通过 `cnt[x] += 1` 来增加这个数字的计数。
```python
    def maxSubarrayLength(nums, k):
        ans = left = 0
        cnt = Counter()
        for right, x in enumerate(nums):
            cnt[x] += 1
            while cnt[x] > k:
                cnt[nums[left]] -= 1
                left += 1
            ans = max(ans, right - left + 1)
```
- 代码其余部分与滑动窗口框架相同。
- 实际上也可以直接创建字典`dict`
```python
    cnt = dict()
    for right, x in enumerate(nums):
        cnt[x] = cnt.get(x, 0) + 1
        while cnt[x] > k:
            cnt[nums[left]] -= 1
            left += 1
        ans = max(ans, right - left + 1)
    return ans
```






