# 将 x 减到 0 的最小操作数

## 题目描述
给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从`x`中减去该元素的值。请注意需修改数组以供接下来的操作使用。

如果可以将`x`恰好减到`0`，返回最小操作数 ；否则，返回 `-1` 。

示例 1：

输入：`nums = [1,1,4,2,3]`, `x = 5`
输出：`2`
解释：最佳解决方案是移除后两个元素，将`x`减到`0`。
示例 2：

输入：`nums = [5,6,7,8,9]`, `x = 4`
输出：`-1`

提示：

`1 <= nums.length <= 105`
`1 <= nums[i] <= 104`
`1 <= x <= 109`

## 解题思路
- 首先要注意到提示中，数组内的元素和`X`都是正数。
- 没有思路，直接看的0x3f的题解。还有直接用双指针解决的，不太好理解，所以不写了。
### 思路：逆向思维
- 把问题转换成`从数组中选出一个子数组，使得剩余的元素和为x`，进一步转换成`从数组中选出一个子数组，使得子数组的和为sum-x`，`sum`为数组`nums`中的所有元素和。
- 因此，问题转换为滑动窗口问题，那么三要素：左右指针的位置，左右指针如何移动以及答案如何更新。
- 首先是可以优化，如果`sum < x`，那么直接返回`-1`。因为所有元素加起来都没有`x`大，所以不可能将`x`减到`0`。
```python
    target = sum(nums) - x
    if target < 0:
        return -1
```
- 答案`ans`初始化为`-1`，因为可能不存在满足条件的子数组，这时候要返回`-1`。左右指针均在第一个元素处开始遍历。同时还需要一个变量`s`记录窗口内的元素和,当窗口内的元素和大于`sum-x`时，左指针右移，当窗口内的元素和小于`sum-x`时，右指针右移。
```python
    ans = -1
    left = 0
    for right,val in enumerate(nums):
        s += val
        while s > sum - x:
            s -= nums[left]
            left += 1
```
- 对于答案的更新，`ans` 并不是我们想要的最终结果，因为它是子数组的长度，我们需要的是移除子数组后剩余的元素数最少，所以需要`return`的是`len(nums) - ans`,这就需要`ans`是最大的。
- 同时我们还需要一个判断条件，就是子数组外的元素和正好为`x`的时候更新答案。
```python
        if s == sum - x:
            ans = max(ans,right - left + 1)
    return -1 if ans < 0 else len(nums) - ans
```
- 我设想的答案更新是直接在取值时就是剩余元素的个数,即`ans = min(ans, len(nums) - right - left + 1)`，这样写的话，在初始化`ans`的时候就不能是`-1`，而应是一个无穷大或`len(nums) + 1`
```python
    ans = len(nums) + 1

    ...
    for ...
        ans = min(ans, len(nums) - right - left + 1)
    return -1 if ans > len(nums) else ans
```
- 空间复杂度：`O(1)`,因为只定义了几个变量。时间复杂度：`O(n)`，因为只遍历了一次数组。

