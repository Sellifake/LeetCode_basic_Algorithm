# 长度最小的子数组

## 题目描述

给定一个含有 n 个正整数的数组和一个正整数 `s` ，找出该数组中满足其**和 `≥ s` 的长度最小**的连续子数组的长度。如果不存在符合条件的连续子数组，返回 `0`。

示例:

输入: `s = 7`, `nums = [2,3,1,2,4,3]`
输出: `2`
解释: 子数组 `[4,3]` 是该条件下的长度最小的连续子数组。

## 思路一：暴力法
- 遍历数组中的元素，对于当前元素`i`，再遍历`i`之后的元素，计算和是否大于等于`s`，如果大于等于`s`，则记录下长度，并更新最小长度。
```python
    n = len(nums)
    ans = n+1
    for i in range(n):
        total = 0
        for j in range(i,n):
            total += nums[j]
            if total >= target:
                ans = min(ans, j-i+1)
```
- `total`用来记录当前子数组的和,`ans`用来记录最小长度，初始值为`n+1`，因为最大的长度为`n`。
- 为什么`total`初始化的值是`0`呢，因为`j`是从`i`开始的，最一开始`total += nums[j]`实际上就是`total = nums[i]`。
- 当`total >= target`时，更新最小长度`ans`，为什么是`j-i+1`，`ans`表示的是子数组的长度，而`i`和`j`是指向元素下标的指针，当`i`和`j`指向同一个元素时，长度为`1`，所以需要`+1`。
- 时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。

## 思路二：滑动窗口
- 捕捉题目中的关键词**连续子数组**。
- 滑动窗口的思想就是两个指针，一个指向窗口的左边界，一个指向窗口的右边界，然后根据题目的要求，移动窗口的左边界或者右边界，直到满足题目的要求。**滑动窗口也可以看成是同向双指针，也为双指针的一种**
- 为什么本题适用于滑动窗口呢，有两点。首先需要找到的是一个连续子数组，中间不间断，其次数组内的元素与`target`都是正数，也就是说当我们找到了当前最小长度的子数组之后，右窗口就没有必要继续移动了，因为右窗口再向右移动，子数组的和只会更大。
- 对于这道题，我们可以使用滑动窗口的思想，当窗口的和小于`s`时，移动右边界，当窗口的和大于等于`s`时，移动左边界，直到窗口的和小于`s`，然后更新最小长度。
```python
    n = len(nums)
    ans = n+1
    left = 0
    total = 0
    for right in range(n):
        total += nums[right]
        while total >= target:
            ans = min(ans, right-left+1)
            total -= nums[left]
            left += 1
    return 0 if ans == n+1 else ans
```
- `for right in range(n):`表示开始移动右窗口。
- `total += nums[right]`计算移动之后子数组的和。
- `while total >= target:`表示当窗口的和大于等于`s`时，要开始移动左窗口了。
- `ans = min(ans, right-left+1)`首先更新最小长度。
- `total -= nums[left]`移动左窗口，同时更新子数组的和。
- `left += 1`移动左窗口。
- 最后返回`0 if ans == n+1 else ans`，如果`ans`还是初始值`n+1`，说明没有找到符合条件的子数组，返回`0`，否则返回最小长度`ans`。